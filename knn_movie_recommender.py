# -*- coding: utf-8 -*-
"""KNN_Movie_Recommender.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EfGHtujVCgZTsebvmiWV8ZrEiQyeQrmS
"""

import os
import zipfile
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.neighbors import NearestNeighbors
from scipy.sparse import csr_matrix

pd.set_option("display.max_colwidth", 120)
plt.rcParams["figure.figsize"] = (10, 5)

ratings = pd.read_csv("/content/ratings.csv")
movies  = pd.read_csv("/content/movies.csv")

print("Ratings shape:", ratings.shape)
print("Movies shape:", movies.shape)

ratings.head(), movies.head()

sns.histplot(ratings["rating"], bins=9, kde=False)
plt.title("Distribution of Ratings")
plt.xlabel("Rating")
plt.ylabel("Count")
plt.show()

ratings["rating"].describe()

popularity = (
    ratings.groupby("movieId")["rating"]
    .count()
    .reset_index(name="num_ratings")
    .merge(movies, on="movieId", how="left")
    .sort_values("num_ratings", ascending=False)
)

top10 = popularity.head(10)
ax = sns.barplot(data=top10, x="num_ratings", y="title")
ax.set_title("Top 10 Most Rated Movies")
ax.set_xlabel("Number of Ratings")
ax.set_ylabel("")
plt.show()

top10[["title", "num_ratings"]]

movies_genres = movies.copy()
movies_genres["genres"] = movies_genres["genres"].str.split("|")
movies_exploded = movies_genres.explode("genres")

avg_by_genre = (
    ratings.merge(movies_exploded, on="movieId")
    .groupby("genres")["rating"].mean()
    .sort_values(ascending=False)
    .reset_index()
)

sns.barplot(data=avg_by_genre, x="rating", y="genres")
plt.title("Average Rating by Genre")
plt.xlabel("Average Rating")
plt.ylabel("Genre")
plt.show()

avg_by_genre

user_item = ratings.pivot_table(index="userId", columns="movieId", values="rating")


user_item_filled = user_item.fillna(0)

item_user_matrix = csr_matrix(user_item_filled.values.T)

item_user_matrix.shape

# KNN on movies
knn = NearestNeighbors(metric="cosine", algorithm="brute")
knn.fit(item_user_matrix)


movie_id_to_title = dict(zip(movies["movieId"], movies["title"]))
movie_ids = user_item_filled.columns.tolist()
title_to_index = {movie_id_to_title[mid]: idx for idx, mid in enumerate(movie_ids)}

def recommend_similar_movies(input_title, n_neighbors=10, return_n=5, min_common_users=5):
    """
    Given a movie title, return top-N similar movies using item-based KNN (cosine).
    Filters neighbors with too few overlapping raters (optional heuristic).
    """
    # Robust title match
    titles_lower = pd.Series(movie_id_to_title[mid] for mid in movie_ids).str.lower()
    matches = titles_lower[titles_lower.str.contains(input_title.lower(), na=False)]
    if matches.empty:
        raise ValueError(f"No title match found for '{input_title}'. Try a different keyword.")

    # Choosing the best/first match and get its matrix index
    chosen_title = matches.iloc[0]
    # Recovering exact cased title
    exact_title = pd.Series(movie_id_to_title[mid] for mid in movie_ids)[matches.index[0]]
    idx = matches.index[0]

    # Querying KNN
    distances, indices = knn.kneighbors(item_user_matrix[idx], n_neighbors=n_neighbors + 1)
    distances = distances.flatten()
    indices = indices.flatten()

    # Building candidate table
    candidates = []
    this_movie_vector = item_user_matrix[idx].toarray().ravel()
    this_nonzero = set(np.where(this_movie_vector > 0)[0])

    for dist, ind in zip(distances[1:], indices[1:]):
        neighbor_mid = movie_ids[ind]
        neighbor_title = movie_id_to_title[neighbor_mid]


        neighbor_vec = item_user_matrix[ind].toarray().ravel()
        overlap = len(this_nonzero.intersection(set(np.where(neighbor_vec > 0)[0])))
        if overlap >= min_common_users:
            sim = 1 - dist
            candidates.append({"title": neighbor_title, "similarity": sim, "overlap_users": overlap})

    recs = pd.DataFrame(candidates).sort_values(["similarity", "overlap_users"], ascending=False)
    return exact_title, recs.head(return_n).reset_index(drop=True)

query = "toy story"
base_title, recs = recommend_similar_movies(query, n_neighbors=15, return_n=5, min_common_users=10)

print(f"Input Movie: {base_title}\n")
print("Top 5 Recommendations:")
for i, row in recs.iterrows():
    print(f"{i+1}. {row['title']} (similarity: {row['similarity']:.3f}, overlap_users: {row['overlap_users']})")

recs

# Small CSV of the top 50 most-rated movies for quick testing
popularity.head(50)[["movieId", "title", "num_ratings"]].to_csv("top50_popular_movies.csv", index=False)
print("Saved: top50_popular_movies.csv")